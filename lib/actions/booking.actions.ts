"use server";

import { createClient } from "@supabase/supabase-js";
import { revalidatePath } from "next/cache";
import { sendEmail } from "@/lib/mail";
import {
  getBookingConfirmationEmail,
  getCancellationEmail,
} from "@/lib/mail/templates";

// Initialize Supabase Admin strictly for server actions
const supabaseAdmin = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!,
  {
    auth: {
      persistSession: false,
    },
  }
);

interface CreateBookingParams {
  eventId: string;
  slug: string;
  email: string;
  name: string;
  metadata?: Record<string, unknown>;
}

/**
 * Creates a booking for an event
 * - Validates event exists and has capacity
 * - Checks for duplicate bookings
 * - Creates booking with auto-generated UUID ticket code
 */
export const createBooking = async ({
  eventId,
  slug,
  email,
  name,
  metadata,
}: CreateBookingParams) => {
  try {
    console.log(`[Booking] Starting for event: ${slug}, user: ${email}`);

    const numericEventId = parseInt(eventId, 10);
    if (isNaN(numericEventId)) {
      return { success: false, error: "Invalid event ID" };
    }

    // 1. Fetch Event Capacity
    const { data: eventData, error: eventError } = await supabaseAdmin
      .from("events")
      .select("capacity, title, location, date, time")
      .eq("id", numericEventId)
      .single();

    if (eventError || !eventData) {
      return { success: false, error: "Event not found" };
    }

    // 2. Check count for capacity
    const { count: currentBookings, error: countError } = await supabaseAdmin
      .from("bookings")
      .select("*", { count: "exact", head: true })
      .eq("event_id", numericEventId);

    if (countError) {
      return { success: false, error: "System error checking capacity" };
    }

    // Capacity Check
    if (eventData.capacity && (currentBookings || 0) >= eventData.capacity) {
      return { success: false, error: "Event is fully booked!" };
    }

    // 3. Check for duplicate booking
    const { data: existing } = await supabaseAdmin
      .from("bookings")
      .select("id")
      .eq("event_id", numericEventId)
      .eq("email", email)
      .single();

    if (existing) {
      return { success: false, error: "You have already booked this event." };
    }

    // 4. Insert Booking (ticket_code auto-generated by database as UUID)
    const { data: newBooking, error: insertError } = await supabaseAdmin
      .from("bookings")
      .insert({
        event_id: numericEventId,
        email,
        status: "confirmed",
        metadata: {
          name,
          ...metadata,
        },
      })
      .select("ticket_code")
      .single();

    if (insertError || !newBooking) {
      console.error("Booking insert failed:", insertError);
      return { success: false, error: "Failed to confirm booking." };
    }

    // Format ticket code for display (first 8 chars of UUID)
    const displayCode = `DE-${newBooking.ticket_code
      .substring(0, 8)
      .toUpperCase()}`;
    console.log(`[Booking] Success! Code: ${displayCode}`);

    // Send confirmation email (async, non-blocking)
    try {
      const emailHtml = getBookingConfirmationEmail({
        attendeeName: name,
        eventName: eventData.title,
        eventDate: new Date(eventData.date).toLocaleDateString("en-US", {
          weekday: "long",
          year: "numeric",
          month: "long",
          day: "numeric",
        }),
        eventTime: eventData.time || "TBA",
        eventLocation: eventData.location || "Online",
        ticketCode: displayCode,
      });
      await sendEmail(
        email,
        `Booking Confirmed: ${eventData.title}`,
        emailHtml
      );
      console.log(`[Booking] Confirmation email sent to ${email}`);
    } catch (emailError) {
      // Don't fail the booking if email fails
      console.error("Failed to send confirmation email:", emailError);
    }

    revalidatePath(`/events/${slug}`);
    revalidatePath("/admin");

    return {
      success: true,
      ticket: {
        ticketCode: displayCode,
        eventName: eventData.title,
        attendeeName: name,
        date: new Date(eventData.date).toLocaleDateString(),
        location: eventData.location,
      },
    };
  } catch (e) {
    console.error("create booking failed", e);
    return { success: false, error: "Internal server error" };
  }
};

export const getUserBookings = async (email: string) => {
  try {
    const { data, error } = await supabaseAdmin
      .from("bookings")
      .select("*, events(title, date, location, time, image)")
      .eq("email", email)
      .order("created_at", { ascending: false });

    if (error) {
      console.error("Error fetching user bookings:", error);
      return [];
    }

    return data || [];
  } catch (error) {
    console.error("Unexpected error fetching bookings:", error);
    return [];
  }
};

/**
 * Cancels a booking
 * - Validates booking exists and belongs to user
 * - Updates status to cancelled
 */
export const cancelBooking = async (bookingId: string, email: string) => {
  try {
    console.log(`[Booking] Cancelling booking: ${bookingId} for ${email}`);

    // Verify the booking exists and belongs to this email
    const { data: booking, error: fetchError } = await supabaseAdmin
      .from("bookings")
      .select("id, email, status, event_id, events(title, slug)")
      .eq("id", bookingId)
      .single();

    if (fetchError || !booking) {
      return { success: false, error: "Booking not found" };
    }

    if (booking.email !== email) {
      return { success: false, error: "Unauthorized to cancel this booking" };
    }

    if (booking.status === "cancelled") {
      return { success: false, error: "Booking is already cancelled" };
    }

    // Update booking status to cancelled
    const { error: updateError } = await supabaseAdmin
      .from("bookings")
      .update({ status: "cancelled" })
      .eq("id", bookingId);

    if (updateError) {
      console.error("Cancel booking failed:", updateError);
      return { success: false, error: "Failed to cancel booking" };
    }

    // Revalidate paths
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const event = booking.events as any;
    if (event?.slug) {
      revalidatePath(`/events/${event.slug}`);
    }
    revalidatePath("/settings");
    revalidatePath("/admin");

    // Send cancellation email (async, non-blocking)
    try {
      // Get attendee name from booking metadata
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      const metadata = booking.metadata as any;
      const attendeeName = metadata?.name || "Attendee";

      const emailHtml = getCancellationEmail({
        attendeeName,
        eventName: event?.title || "Event",
      });
      await sendEmail(
        email,
        `Booking Cancelled: ${event?.title || "Event"}`,
        emailHtml
      );
      console.log(`[Booking] Cancellation email sent to ${email}`);
    } catch (emailError) {
      // Don't fail the cancellation if email fails
      console.error("Failed to send cancellation email:", emailError);
    }

    console.log(`[Booking] Successfully cancelled booking: ${bookingId}`);
    return { success: true };
  } catch (error) {
    console.error("Cancel booking error:", error);
    return { success: false, error: "Internal server error" };
  }
};

/**
 * Get event capacity information
 */
export const getEventCapacity = async (eventId: string) => {
  try {
    const numericEventId = parseInt(eventId, 10);
    if (isNaN(numericEventId)) {
      return { capacity: null, booked: 0, available: null };
    }

    // Get event capacity
    const { data: event } = await supabaseAdmin
      .from("events")
      .select("capacity")
      .eq("id", numericEventId)
      .single();

    // Get current booking count
    const { count } = await supabaseAdmin
      .from("bookings")
      .select("*", { count: "exact", head: true })
      .eq("event_id", numericEventId)
      .eq("status", "confirmed");

    const booked = count || 0;
    const capacity = event?.capacity || null;
    const available = capacity ? capacity - booked : null;

    return { capacity, booked, available };
  } catch (error) {
    console.error("Get capacity error:", error);
    return { capacity: null, booked: 0, available: null };
  }
};
